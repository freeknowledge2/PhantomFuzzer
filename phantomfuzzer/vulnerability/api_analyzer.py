#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
API vulnerability analyzer for PhantomFuzzer.

This module provides a specialized analyzer for detecting vulnerabilities in APIs.
"""

import re
import json
from urllib.parse import urlparse, urljoin
from typing import Dict, List, Any, Optional, Union, Set

# Import from phantomfuzzer package
from phantomfuzzer.utils.logging import get_module_logger
from phantomfuzzer.utils.helper import print_info, print_warning, print_error

# Import from vulnerability module
from phantomfuzzer.vulnerability.base_analyzer import BaseAnalyzer
from phantomfuzzer.vulnerability.models import Vulnerability

# Import vulnerability constants
from phantomfuzzer.vulnerability import (
    # Severity levels
    SEVERITY_CRITICAL, SEVERITY_HIGH, SEVERITY_MEDIUM, SEVERITY_LOW, SEVERITY_INFO,
    
    # Vulnerability categories
    CATEGORY_BROKEN_ACCESS_CONTROL, CATEGORY_CRYPTO_FAILURES, CATEGORY_INJECTION,
    CATEGORY_INSECURE_DESIGN, CATEGORY_SECURITY_MISCONFIG, CATEGORY_VULNERABLE_COMPONENTS,
    CATEGORY_AUTH_FAILURES, CATEGORY_SOFTWARE_DATA_INTEGRITY, CATEGORY_LOGGING_MONITORING,
    CATEGORY_SSRF, CATEGORY_SQLI
)


class APIAnalyzer(BaseAnalyzer):
    """Specialized analyzer for detecting vulnerabilities in APIs."""
    
    def _load_patterns(self) -> Dict[str, Any]:
        """Load vulnerability patterns for API analysis.
        
        Returns:
            A dictionary of vulnerability patterns.
        """
        # Authentication vulnerability patterns
        auth_patterns = {
            'missing_auth': {
                'description': 'API endpoint with missing authentication',
                'severity': SEVERITY_HIGH,
                'category': CATEGORY_AUTH_FAILURES,
                'remediation': 'Implement proper authentication for all API endpoints.'
            },
            'weak_auth': {
                'description': 'API endpoint with weak authentication',
                'severity': SEVERITY_MEDIUM,
                'category': CATEGORY_AUTH_FAILURES,
                'remediation': 'Strengthen authentication mechanisms using industry standards.'
            }
        }
        
        # Authorization vulnerability patterns
        authz_patterns = {
            'missing_authz': {
                'description': 'API endpoint with missing authorization',
                'severity': SEVERITY_HIGH,
                'category': CATEGORY_BROKEN_ACCESS_CONTROL,
                'remediation': 'Implement proper authorization checks for all API endpoints.'
            },
            'insecure_direct_object_ref': {
                'description': 'Insecure direct object reference vulnerability',
                'severity': SEVERITY_HIGH,
                'category': CATEGORY_BROKEN_ACCESS_CONTROL,
                'remediation': 'Implement proper access control and use indirect references.'
            }
        }
        
        # Injection vulnerability patterns
        injection_patterns = {
            'sql_injection': {
                'pattern': r'(?i)(?:SQL syntax.*?MySQL|Warning.*?\\Wmysqli?_|MySQLSyntaxErrorException|valid MySQL result|check the manual that corresponds to your MySQL server version|Unknown column \'[^\']+\' in \'field list\'|MySqlClient\\.|com\\.mysql\\.jdbc|Zend_Db_Statement_Mysqli_Exception)',
                'description': 'Potential SQL injection vulnerability',
                'severity': SEVERITY_HIGH,
                'category': CATEGORY_SQLI,
                'remediation': 'Use parameterized queries or prepared statements.'
            },
            'nosql_injection': {
                'pattern': r'(?i)(?:CastError|BSONObj|BSONElement|cannot be cast to)',
                'description': 'Potential NoSQL injection vulnerability',
                'severity': SEVERITY_HIGH,
                'category': CATEGORY_INJECTION,
                'remediation': 'Validate and sanitize user input before using in database queries.'
            }
        }
        
        # Security misconfiguration patterns
        security_misconfig_patterns = {
            'cors_misconfiguration': {
                'description': 'CORS misconfiguration detected',
                'severity': SEVERITY_MEDIUM,
                'category': CATEGORY_SECURITY_MISCONFIG,
                'remediation': 'Configure CORS with appropriate restrictions.'
            },
            'excessive_data_exposure': {
                'description': 'API endpoint exposing excessive data',
                'severity': SEVERITY_MEDIUM,
                'category': CATEGORY_INSECURE_DESIGN,
                'remediation': 'Limit the data returned to only what is necessary.'
            }
        }
        
        # Security headers patterns
        security_headers_patterns = {
            'missing_rate_limit': {
                'header': 'X-RateLimit-Limit',
                'description': 'Missing rate limiting headers',
                'severity': SEVERITY_MEDIUM,
                'category': CATEGORY_SECURITY_MISCONFIG,
                'remediation': 'Implement rate limiting to prevent abuse.'
            },
            'missing_content_type': {
                'header': 'Content-Type',
                'description': 'Missing Content-Type header',
                'severity': SEVERITY_LOW,
                'category': CATEGORY_SECURITY_MISCONFIG,
                'remediation': 'Always specify Content-Type header in API responses.'
            }
        }
        
        return {
            'auth': auth_patterns,
            'authz': authz_patterns,
            'injection': injection_patterns,
            'security_misconfig': security_misconfig_patterns,
            'security_headers': security_headers_patterns
        }
    
    def analyze(self, target: str, scan_context: Optional[Dict[str, Any]] = None) -> List[Vulnerability]:
        """Analyze an API for vulnerabilities.
        
        Args:
            target: The URL of the API to analyze.
            scan_context: Optional context information about the scan.
        
        Returns:
            A list of detected vulnerabilities.
        """
        # Validate URL
        if not self._is_valid_url(target):
            self.logger.error(f"Invalid API URL: {target}")
            print_error(f"Invalid API URL: {target}")
            return []
        
        # Initialize list to store detected vulnerabilities
        vulnerabilities = []
        
        try:
            # Import requests library (only when needed)
            try:
                import requests
                from requests.exceptions import RequestException
            except ImportError:
                self.logger.error("Requests library not available. Cannot analyze API.")
                print_error("Requests library not available. Cannot analyze API.")
                return []
            
            # Set up session with proper headers
            session = requests.Session()
            session.headers.update({
                'User-Agent': 'PhantomFuzzer/1.0 API Vulnerability Scanner',
                'Accept': 'application/json, text/plain, */*',
                'Content-Type': 'application/json'
            })
            
            # Make initial request to the target
            self.logger.info(f"Analyzing API: {target}")
            print_info(f"Analyzing API: {target}")
            
            # Check if API specification is available
            spec_url = None
            if scan_context and 'api_spec' in scan_context:
                spec_url = scan_context['api_spec']
            elif target.endswith('/'):
                # Try common API specification paths
                for path in ['swagger.json', 'openapi.json', 'api-docs', 'swagger-ui.html']:
                    try:
                        spec_response = session.get(urljoin(target, path), verify=False, timeout=5)
                        if spec_response.status_code == 200:
                            spec_url = urljoin(target, path)
                            break
                    except:
                        continue
            
            # If API specification is available, analyze it
            if spec_url:
                self._analyze_api_spec(spec_url, session, vulnerabilities)
            
            # Perform active scanning if requested
            if scan_context and scan_context.get('active_scan', False):
                self._active_scan(target, session, vulnerabilities, scan_context)
            
            # Check security headers
            try:
                response = session.options(target, verify=False, timeout=5)
                self._check_security_headers(target, response.headers, vulnerabilities)
            except:
                self.logger.warning(f"Could not perform OPTIONS request on {target}")
            
            # Use ML for enhanced detection if enabled
            if self.ml_enabled and self.ml_integration:
                self._analyze_with_ml(target, vulnerabilities)
            
            return vulnerabilities
            
        except Exception as e:
            self._handle_exception(e, f"Error analyzing API {target}")
            return vulnerabilities
    
    def _is_valid_url(self, url: str) -> bool:
        """Check if a URL is valid.
        
        Args:
            url: The URL to check.
        
        Returns:
            True if the URL is valid, False otherwise.
        """
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc]) and result.scheme in ['http', 'https']
        except Exception:
            return False
    
    def _analyze_api_spec(self, spec_url: str, session, vulnerabilities: List[Vulnerability]) -> None:
        """Analyze an API specification for vulnerabilities.
        
        Args:
            spec_url: The URL of the API specification.
            session: The requests session to use.
            vulnerabilities: The list to add detected vulnerabilities to.
        """
        try:
            # Get the API specification
            response = session.get(spec_url, verify=False, timeout=10)
            
            # Check if the response is JSON
            if 'application/json' in response.headers.get('Content-Type', ''):
                spec = response.json()
            else:
                self.logger.warning(f"API specification at {spec_url} is not JSON")
                return
            
            # Check for OpenAPI/Swagger specification
            if 'swagger' in spec or 'openapi' in spec:
                self._analyze_openapi_spec(spec_url, spec, vulnerabilities)
            else:
                self.logger.warning(f"Unknown API specification format at {spec_url}")
        
        except Exception as e:
            self._handle_exception(e, f"Error analyzing API specification at {spec_url}")
    
    def _analyze_openapi_spec(self, spec_url: str, spec: Dict[str, Any], vulnerabilities: List[Vulnerability]) -> None:
        """Analyze an OpenAPI/Swagger specification for vulnerabilities.
        
        Args:
            spec_url: The URL of the API specification.
            spec: The parsed API specification.
            vulnerabilities: The list to add detected vulnerabilities to.
        """
        try:
            # Check for security definitions
            has_security_definitions = False
            
            # Check for OpenAPI 2.0 (Swagger)
            if 'swagger' in spec and spec['swagger'].startswith('2.'):
                has_security_definitions = 'securityDefinitions' in spec and spec['securityDefinitions']
            
            # Check for OpenAPI 3.0+
            elif 'openapi' in spec and spec['openapi'].startswith('3.'):
                has_security_definitions = 'components' in spec and 'securitySchemes' in spec.get('components', {})
            
            # Check for missing authentication
            if not has_security_definitions:
                vulnerabilities.append(Vulnerability(
                    name="Missing API Authentication",
                    description=self.patterns['auth']['missing_auth']['description'],
                    severity=self.patterns['auth']['missing_auth']['severity'],
                    location=spec_url,
                    category=self.patterns['auth']['missing_auth']['category'],
                    evidence="No security definitions found in API specification",
                    remediation=self.patterns['auth']['missing_auth']['remediation'],
                    detection_method="api_spec_analysis"
                ))
            
            # Check for endpoints without security requirements
            paths = spec.get('paths', {})
            for path, path_item in paths.items():
                for method, operation in path_item.items():
                    if method not in ['get', 'post', 'put', 'delete', 'patch', 'options', 'head']:
                        continue
                    
                    # Check if the operation has security requirements
                    has_security = False
                    
                    # Check operation-level security
                    if 'security' in operation:
                        has_security = bool(operation['security'])
                    
                    # Check global security if no operation-level security
                    elif 'security' in spec:
                        has_security = bool(spec['security'])
                    
                    # Report vulnerability if no security requirements
                    if not has_security:
                        vulnerabilities.append(Vulnerability(
                            name="Unsecured API Endpoint",
                            description=f"API endpoint {method.upper()} {path} has no security requirements",
                            severity=self.patterns['auth']['missing_auth']['severity'],
                            location=f"{spec_url}#{path}",
                            category=self.patterns['auth']['missing_auth']['category'],
                            evidence=f"No security requirements for {method.upper()} {path}",
                            remediation=self.patterns['auth']['missing_auth']['remediation'],
                            detection_method="api_spec_analysis"
                        ))
        
        except Exception as e:
            self._handle_exception(e, f"Error analyzing OpenAPI specification at {spec_url}")
    
    def _active_scan(self, base_url: str, session, vulnerabilities: List[Vulnerability], scan_context: Dict[str, Any]) -> None:
        """Perform active scanning of API endpoints.
        
        Args:
            base_url: The base URL of the API.
            session: The requests session to use.
            vulnerabilities: The list to add detected vulnerabilities to.
            scan_context: Context information about the scan.
        """
        try:
            # Get endpoints to scan
            endpoints = scan_context.get('endpoints', [])
            
            # If no endpoints provided, try to discover them
            if not endpoints:
                endpoints = self._discover_endpoints(base_url, session)
            
            # Scan each endpoint
            for endpoint in endpoints:
                url = urljoin(base_url, endpoint)
                
                # Test for authentication bypass
                self._test_auth_bypass(url, session, vulnerabilities)
                
                # Test for injection vulnerabilities
                self._test_injection(url, session, vulnerabilities)
                
                # Test for excessive data exposure
                self._test_data_exposure(url, session, vulnerabilities)
        
        except Exception as e:
            self._handle_exception(e, f"Error during active scanning of {base_url}")
    
    def _discover_endpoints(self, base_url: str, session) -> List[str]:
        """Discover API endpoints.
        
        Args:
            base_url: The base URL of the API.
            session: The requests session to use.
        
        Returns:
            A list of discovered endpoints.
        """
        endpoints = []
        
        try:
            # Try to get API specification
            for path in ['swagger.json', 'openapi.json', 'api-docs']:
                try:
                    spec_url = urljoin(base_url, path)
                    response = session.get(spec_url, verify=False, timeout=5)
                    
                    if response.status_code == 200 and 'application/json' in response.headers.get('Content-Type', ''):
                        spec = response.json()
                        
                        # Extract endpoints from OpenAPI/Swagger specification
                        if ('swagger' in spec or 'openapi' in spec) and 'paths' in spec:
                            for path in spec['paths'].keys():
                                endpoints.append(path)
                            
                            return endpoints
                except:
                    continue
            
            # If no specification found, try common endpoints
            common_endpoints = [
                'users', 'user', 'accounts', 'account', 'profile', 'profiles',
                'auth', 'login', 'register', 'signup', 'signin',
                'products', 'product', 'items', 'item',
                'orders', 'order', 'cart', 'checkout',
                'api', 'v1', 'v2', 'v3', 'api/v1', 'api/v2', 'api/v3'
            ]
            
            for endpoint in common_endpoints:
                try:
                    url = urljoin(base_url, endpoint)
                    response = session.get(url, verify=False, timeout=5)
                    
                    # If we get a 200 OK or 401 Unauthorized, it's likely an endpoint
                    if response.status_code in [200, 401]:
                        endpoints.append(endpoint)
                except:
                    continue
        
        except Exception as e:
            self.logger.warning(f"Error discovering endpoints: {str(e)}")
        
        return endpoints
    
    def _test_auth_bypass(self, url: str, session, vulnerabilities: List[Vulnerability]) -> None:
        """Test for authentication bypass vulnerabilities.
        
        Args:
            url: The URL to test.
            session: The requests session to use.
            vulnerabilities: The list to add detected vulnerabilities to.
        """
        try:
            # Make a request without authentication
            original_auth = session.headers.get('Authorization')
            if original_auth:
                del session.headers['Authorization']
            
            response = session.get(url, verify=False, timeout=5)
            
            # Check if the request succeeded without authentication
            if response.status_code == 200:
                # Try to determine if the response contains sensitive data
                is_sensitive = False
                
                # Check for common sensitive data patterns in JSON responses
                if 'application/json' in response.headers.get('Content-Type', ''):
                    try:
                        data = response.json()
                        
                        # Check for sensitive fields
                        sensitive_fields = ['password', 'token', 'key', 'secret', 'credit_card', 'ssn', 'social_security']
                        
                        # Recursively check for sensitive fields
                        def check_sensitive(obj):
                            if isinstance(obj, dict):
                                for key in obj:
                                    if any(field in key.lower() for field in sensitive_fields):
                                        return True
                                    if check_sensitive(obj[key]):
                                        return True
                            elif isinstance(obj, list):
                                for item in obj:
                                    if check_sensitive(item):
                                        return True
                            return False
                        
                        is_sensitive = check_sensitive(data)
                    except:
                        pass
                
                # Report vulnerability if sensitive data is exposed
                if is_sensitive:
                    vulnerabilities.append(Vulnerability(
                        name="Authentication Bypass",
                        description="API endpoint accessible without authentication",
                        severity=SEVERITY_HIGH,
                        location=url,
                        category=CATEGORY_AUTH_FAILURES,
                        evidence="Endpoint returns sensitive data without authentication",
                        remediation="Implement proper authentication for all API endpoints",
                        detection_method="active_testing"
                    ))
            
            # Restore original authentication header
            if original_auth:
                session.headers['Authorization'] = original_auth
        
        except Exception as e:
            self.logger.debug(f"Error testing authentication bypass for {url}: {str(e)}")
    
    def _test_injection(self, url: str, session, vulnerabilities: List[Vulnerability]) -> None:
        """Test for injection vulnerabilities.
        
        Args:
            url: The URL to test.
            session: The requests session to use.
            vulnerabilities: The list to add detected vulnerabilities to.
        """
        try:
            # SQL injection test payloads
            sql_payloads = ["'", "' OR '1'='1", "'; --", "' OR 1=1; --"]
            
            # Make a request with each payload
            for payload in sql_payloads:
                # Try in URL parameter
                test_url = f"{url}?id={payload}"
                response = session.get(test_url, verify=False, timeout=5)
                
                # Check for SQL error messages
                for pattern in self.patterns['injection']['sql_injection']['pattern'].split('|'):
                    if re.search(pattern, response.text):
                        vulnerabilities.append(Vulnerability(
                            name="SQL Injection Vulnerability",
                            description=self.patterns['injection']['sql_injection']['description'],
                            severity=self.patterns['injection']['sql_injection']['severity'],
                            location=url,
                            category=self.patterns['injection']['sql_injection']['category'],
                            evidence=f"SQL error detected with payload: {payload}",
                            remediation=self.patterns['injection']['sql_injection']['remediation'],
                            detection_method="active_testing"
                        ))
                        break
        
        except Exception as e:
            self.logger.debug(f"Error testing injection for {url}: {str(e)}")
    
    def _test_data_exposure(self, url: str, session, vulnerabilities: List[Vulnerability]) -> None:
        """Test for excessive data exposure vulnerabilities.
        
        Args:
            url: The URL to test.
            session: The requests session to use.
            vulnerabilities: The list to add detected vulnerabilities to.
        """
        try:
            # Make a request to the endpoint
            response = session.get(url, verify=False, timeout=5)
            
            # Check if the response is JSON
            if response.status_code == 200 and 'application/json' in response.headers.get('Content-Type', ''):
                try:
                    data = response.json()
                    
                    # Check for sensitive fields
                    sensitive_fields = ['password', 'hash', 'secret', 'token', 'key', 'credit_card', 'ssn', 'social_security']
                    
                    # Recursively check for sensitive fields
                    def check_sensitive(obj, path=""):
                        found = []
                        if isinstance(obj, dict):
                            for key in obj:
                                new_path = f"{path}.{key}" if path else key
                                if any(field in key.lower() for field in sensitive_fields):
                                    found.append((new_path, obj[key]))
                                found.extend(check_sensitive(obj[key], new_path))
                        elif isinstance(obj, list):
                            for i, item in enumerate(obj):
                                new_path = f"{path}[{i}]"
                                found.extend(check_sensitive(item, new_path))
                        return found
                    
                    sensitive_data = check_sensitive(data)
                    
                    # Report vulnerability if sensitive data is exposed
                    if sensitive_data:
                        evidence = "Sensitive fields found: " + ", ".join(field for field, _ in sensitive_data[:3])
                        
                        vulnerabilities.append(Vulnerability(
                            name="Excessive Data Exposure",
                            description=self.patterns['security_misconfig']['excessive_data_exposure']['description'],
                            severity=self.patterns['security_misconfig']['excessive_data_exposure']['severity'],
                            location=url,
                            category=self.patterns['security_misconfig']['excessive_data_exposure']['category'],
                            evidence=evidence,
                            remediation=self.patterns['security_misconfig']['excessive_data_exposure']['remediation'],
                            detection_method="active_testing"
                        ))
                except:
                    pass
        
        except Exception as e:
            self.logger.debug(f"Error testing data exposure for {url}: {str(e)}")
    
    def _check_security_headers(self, url: str, headers: Dict[str, str], vulnerabilities: List[Vulnerability]) -> None:
        """Check for missing or misconfigured security headers.
        
        Args:
            url: The URL being analyzed.
            headers: The HTTP response headers.
            vulnerabilities: The list to add detected vulnerabilities to.
        """
        try:
            # Convert header names to lowercase for case-insensitive comparison
            headers_lower = {k.lower(): v for k, v in headers.items()}
            
            for name, header_info in self.patterns['security_headers'].items():
                header_name = header_info['header'].lower()
                
                if header_name not in headers_lower:
                    # Create a vulnerability for missing header
                    vulnerabilities.append(Vulnerability(
                        name=f"Missing {header_info['header']} Header",
                        description=header_info['description'],
                        severity=header_info['severity'],
                        location=url,
                        category=header_info['category'],
                        evidence=f"Header not found in response",
                        remediation=header_info['remediation'],
                        detection_method="header_check"
                    ))
        except Exception as e:
            self._handle_exception(e, f"Error checking security headers for {url}")
    
    def _analyze_with_ml(self, url: str, vulnerabilities: List[Vulnerability]) -> None:
        """Use ML to enhance vulnerability detection.
        
        Args:
            url: The URL being analyzed.
            vulnerabilities: The list to add detected vulnerabilities to.
        """
        try:
            if self.ml_integration:
                # Get ML predictions
                ml_vulnerabilities = self.ml_integration.analyze_api(url)
                
                # Add ML-detected vulnerabilities to the list
                for vuln in ml_vulnerabilities:
                    vulnerabilities.append(Vulnerability(
                        name=vuln['name'],
                        description=vuln['description'],
                        severity=vuln['severity'],
                        location=url,
                        category=vuln.get('category'),
                        evidence=vuln.get('evidence'),
                        remediation=vuln.get('remediation'),
                        detection_method="machine_learning",
                        confidence=vuln.get('confidence', 0.8)
                    ))
        except Exception as e:
            self._handle_exception(e, f"Error during ML analysis of {url}")
