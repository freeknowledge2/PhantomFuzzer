#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Vulnerability models for PhantomFuzzer.

This module provides data models for representing vulnerabilities
and related concepts in the vulnerability analysis system.
"""

import json
import uuid
import hashlib
from datetime import datetime
from typing import Dict, List, Any, Optional, Union

# Import vulnerability constants
from phantomfuzzer.vulnerability import (
    # Severity levels
    SEVERITY_CRITICAL, SEVERITY_HIGH, SEVERITY_MEDIUM, SEVERITY_LOW, SEVERITY_INFO,
    
    # Vulnerability categories
    CATEGORY_BROKEN_ACCESS_CONTROL, CATEGORY_CRYPTO_FAILURES, CATEGORY_INJECTION,
    CATEGORY_INSECURE_DESIGN, CATEGORY_SECURITY_MISCONFIG, CATEGORY_VULNERABLE_COMPONENTS,
    CATEGORY_AUTH_FAILURES, CATEGORY_SOFTWARE_DATA_INTEGRITY, CATEGORY_LOGGING_MONITORING,
    CATEGORY_SSRF
)


class Vulnerability:
    """Class representing a vulnerability.
    
    This class provides a standardized representation of vulnerabilities
    across different scanners and target types.
    """
    
    def __init__(self, name: str, description: str, severity: str,
                 location: str, category: Optional[str] = None,
                 evidence: Optional[str] = None, remediation: Optional[str] = None,
                 cwe_id: Optional[str] = None, cvss_score: Optional[float] = None,
                 detection_method: Optional[str] = None, confidence: float = 1.0,
                 **details):
        """Initialize a vulnerability.
        
        Args:
            name: The name/type of the vulnerability.
            description: A description of the vulnerability.
            severity: The severity level (one of the SEVERITY_* constants).
            location: The location of the vulnerability (e.g., URL, file path).
            category: Optional category (e.g., OWASP Top 10 category).
            evidence: Optional evidence of the vulnerability.
            remediation: Optional remediation advice.
            cwe_id: Optional Common Weakness Enumeration ID.
            cvss_score: Optional Common Vulnerability Scoring System score.
            detection_method: Optional method used to detect the vulnerability.
            confidence: Confidence level (0.0 to 1.0) in the detection.
            **details: Additional details about the vulnerability.
        """
        self.id = str(uuid.uuid4())
        self.name = name
        self.description = description
        self.severity = severity
        self.location = location
        self.category = category
        self.evidence = evidence
        self.remediation = remediation
        self.cwe_id = cwe_id
        self.cvss_score = cvss_score
        self.detection_method = detection_method
        self.confidence = confidence
        self.details = details
        self.timestamp = datetime.now()
        
        # Generate a hash of the vulnerability for deduplication
        self.hash = self._generate_hash()
    
    def _generate_hash(self) -> str:
        """Generate a hash of the vulnerability for deduplication.
        
        Returns:
            A hash string uniquely identifying this vulnerability.
        """
        # Create a string with the key attributes
        hash_str = f"{self.name}|{self.location}|{self.description}"
        
        # Add evidence if available
        if self.evidence:
            hash_str += f"|{self.evidence}"
        
        # Generate a hash
        return hashlib.md5(hash_str.encode()).hexdigest()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the vulnerability to a dictionary.
        
        Returns:
            A dictionary representation of the vulnerability.
        """
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'severity': self.severity,
            'location': self.location,
            'category': self.category,
            'evidence': self.evidence,
            'remediation': self.remediation,
            'cwe_id': self.cwe_id,
            'cvss_score': self.cvss_score,
            'detection_method': self.detection_method,
            'confidence': self.confidence,
            'details': self.details,
            'timestamp': self.timestamp.isoformat(),
            'hash': self.hash
        }
    
    def to_json(self, pretty: bool = False) -> str:
        """Convert the vulnerability to a JSON string.
        
        Args:
            pretty: Whether to format the JSON with indentation.
        
        Returns:
            A JSON string representation of the vulnerability.
        """
        indent = 4 if pretty else None
        return json.dumps(self.to_dict(), indent=indent)
    
    def __eq__(self, other):
        """Check if two vulnerabilities are equal.
        
        Args:
            other: Another vulnerability to compare with.
        
        Returns:
            True if the vulnerabilities are equal, False otherwise.
        """
        if not isinstance(other, Vulnerability):
            return False
        
        return self.hash == other.hash
    
    def __hash__(self):
        """Get the hash of the vulnerability.
        
        Returns:
            The hash of the vulnerability.
        """
        return hash(self.hash)
